import logging
import re
from datetime import datetime
from typing import TYPE_CHECKING, Dict, Optional


if TYPE_CHECKING:
    from dev_agent import DevAgent

logger = logging.getLogger(__name__)


class WorkflowManager:
    """Handles complex, multi-step workflows for the DevAgent."""

    def __init__(self, agent: "DevAgent") -> None:
        """Метод __init__."""
        self.agent = agent

    def self_improve(self, direct: bool = False) -> Dict[str, object]:
        """Runs the self-improvement process."""
        logger.info("Starting the self-improvement process...")

        if not self.agent.code_fixer or not hasattr(self.agent.code_fixer, "git_module"):
            logger.error("GitModule is not initialized. The self-improvement process is not possible.")
            return {"status": "error", "message": "GitModule not initialized."}

        git = self.agent.code_fixer.git_module  # type: ignore
        original_branch = git.get_default_branch()
        if not git.is_working_directory_clean():
            logger.info("The working directory is not clean. Attempting an automatic commit...")
            git.add_all()
            commit_message = "feat(autocommit): Automatic commit of unsaved changes before self-improvement"
            if not git.commit(commit_message):
                logger.error("Could not create an automatic commit. The self-improvement process is stopped.")
                return {"status": "error", "message": "Auto-commit of dirty working directory failed."}
            logger.info("Automatic commit successfully created.")

        improvement_branch = f"self-improvement-{datetime.now().strftime('%Y%m%d-%H%M%S')}"

        try:
            if not direct:
                if not git.create_and_checkout_branch(improvement_branch):
                    raise RuntimeError(f"Could not create or switch to branch '{improvement_branch}'.")
                logger.info(f"Created and switched to branch '{improvement_branch}' for self-improvement.")
            self.agent._create_documentation_dirs()

            if self.agent.task_queue:
                self.agent.task_queue.add_task(
                    {
                        "type": "self_improvement",
                        "improvement_type": "full_cycle",
                        "options": {
                            "analyze_architecture": True,
                            "improve_code_quality": True,
                            "update_documentation": True,
                            "run_tests": True,
                            "auto_fix": self.agent.config.get("auto_fix", True)
                            if self.agent.config  # type: ignore
                            else True,  # Provide a default value if None
                        },
                    }
                )

            if self.agent.task_dispatcher:
                self.agent.task_dispatcher.process_all_tasks()

            if not git.is_working_directory_clean():
                logger.info("Changes detected. Creating a commit...")
                git.add_all()
                commit_message = "feat(self-improve): Automatic improvements from DevAgent"
                if not git.commit(commit_message):
                    raise RuntimeError("Could not create a commit with the changes.")

                if not direct:
                    logger.info(f"Pushing branch '{improvement_branch}' to remote...")
                    if not git.push(improvement_branch):
                        raise RuntimeError(f"Could not push branch '{improvement_branch}' to the remote repository.")

                    pr_title = f"Automatic self-improvement {datetime.now().strftime('%Y-%m-%d')}"
                    pr_body = "This Pull Request contains automatic improvements generated by DevAgent."
                    pr_info: Optional[Dict[str, object]] = git.create_pull_request(
                        pr_title, pr_body, improvement_branch, original_branch
                    )
                    if pr_info and self.agent.pull_request_monitor:
                        self.agent.pull_request_monitor.add_pr_to_monitor(
                            pr_info["number"], improvement_branch, pr_title
                        )
            else:
                logger.info("No changes to commit after the self-improvement cycle.")

            if not direct:
                git.checkout_branch(original_branch)
            return {
                "status": "success",
                "message": f"Self-improvement process complete. Changes are in branch '{improvement_branch}'.",
            }

        except Exception as e:
            logger.error(f"Critical error during self-improvement: {e}", exc_info=True)
            if not direct:
                logger.info("Rolling back changes...")
                git.checkout_branch(original_branch)
                git.delete_branch(improvement_branch)
                logger.info(f"Branch '{improvement_branch}' deleted. Returned to '{original_branch}'.")
            return {"status": "error", "message": f"Self-improvement failed and was rolled back: {e}"}

    def handle_feature_task(self, task: Dict[str, object]) -> Dict[str, object]:
        """Handles a single feature development task in its own branch."""
        logger.info(f"Handling feature task in a new branch: {task.get('description')}")

        if not self.agent.code_fixer or not hasattr(self.agent.code_fixer, "git_module"):
            logger.error("GitModule is not initialized. The feature development process is not possible.")
            if self.agent.task_queue:
                self.agent.task_queue.mark_failed(task, "GitModule not initialized.")
            return {"status": "error", "message": "GitModule not initialized."}

        git = self.agent.code_fixer.git_module  # type: ignore
        original_branch = git.get_current_branch() or git.get_default_branch()

        if not git.is_working_directory_clean():
            logger.warning("The working directory is not clean. Attempting an automatic commit...")
            git.add_all()
            commit_message = "chore(autocommit): Automatic commit of unsaved changes before feature development"
            if not git.commit(commit_message):
                logger.error("Could not create an automatic commit. The development process is stopped.")
                if self.agent.task_queue:
                    self.agent.task_queue.mark_failed(task, "Auto-commit of dirty working directory failed.")
                return {"status": "error", "message": "Auto-commit of dirty working directory failed."}
            logger.info("Automatic commit successfully created.")

        sanitized_desc = re.sub(r"[^a-zA-Z0-9_-]", "-", task.get("description", "task"))[:50]
        task_id = task.get("id", datetime.now().strftime("%f"))
        feature_branch = f"feature/{sanitized_desc}-{task_id[-6:]}"

        try:
            if not git.create_and_checkout_branch(feature_branch):
                raise RuntimeError(f"Could not create or switch to branch '{feature_branch}'.")
            logger.info(f"Created and switched to branch '{feature_branch}' for the task.")

            if self.agent.task_dispatcher:
                self.agent.task_dispatcher.process_task(task)

            if not git.is_working_directory_clean():
                logger.info("Changes detected. Creating a commit...")
                git.add_all()
                commit_message = f"feat: {task.get('description', 'Implement new feature')}"
                if not git.commit(commit_message):
                    raise RuntimeError("Could not create a commit with the changes.")
                git.push(feature_branch)
                pr_title = f"Feature: {task.get('description', 'New Feature')}"
                pr_body = f"This Pull Request implements the following task:\n\n`{task.get('description')}`\n\n(ID: {task.get('id')})"
                pr_info: Optional[Dict[str, object]] = git.create_pull_request(
                    pr_title, pr_body, feature_branch, original_branch
                )
                if pr_info and self.agent.pull_request_monitor:
                    self.agent.pull_request_monitor.add_pr_to_monitor(pr_info["number"], feature_branch, pr_title)

            git.checkout_branch(original_branch)
            return {"status": "success", "message": f"Task processed in branch '{feature_branch}'."}
        except Exception as e:
            logger.error(f"Critical error while processing task in branch '{feature_branch}': {e}", exc_info=True)
            git.checkout_branch(original_branch)
            git.delete_branch(feature_branch)
            if self.agent.task_queue:
                self.agent.task_queue.mark_failed(task, f"Feature handling failed and was rolled back: {e}")
            return {"status": "error", "message": f"Feature handling failed and was rolled back: {e}"}
